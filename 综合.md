### 典中典之前端八股文

#### 一.JS基础

##### 1、原型链

​		每个构造函数都有一个原型对象(`prototype`属性)，原型对象都包含一个指向构造函数的指针(`constructor`属性),而构造函数创建的实例都包含一个指向原型对象的内部指针(`_proto_`)。对象会通过`_proto_`查找对象不存在的属性，直至`Object.prototype`，`Object.prototype`的`_proto_`的值为null。

![image-20210516200517084](https://github.com/ll1035709119/Front-end-knowledge/blob/master/imgs/image-20210516200517084.png)

##### 2、继承的实现

1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。

```javascript
function Parent() {
  this.name = 'fedaily'
}

Parent.prototype.getName = function() {
  return this.name;
}

function Child() {}

// 这里也可以直接写出Child.prototype = Parent.prototype
// 但是这样就不能访问到父类的构造函数的属性了，即this.name
Child.prototype = new Parent()

var child = new Child()
child.getName() // fedaily
```

2、构造继承，构造函数继承其实就是通过修改父类构造函数this实现的继承。我们在子类构造函数中执行父类构造函数，同时修改父类构造函数的this为子类的this。解决了原型链继承中构造函数引用类型共享的问题，同时可以向构造函数传参（通过call传参，缺点是所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法）

```javascript
function Parent() {
  this.name = ['fedaily']
}

function Child() {
  Parent.call(this)
}

var child = new Child()
child.name.push('fe')

var child2 = new Child() // child2.name === ['fedaily']
```

4、组合继承：同时结合原型链继承、构造函数继承,同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题，缺点是父类构造函数被调用了两次。同时子类实例以及子类原型对象上都会存在name属性。

```javascript
function Parent() {
  this.name = 'fedaily'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {
  Parent.call(this)
  this.topic = 'fe'
}

Child.prototype = new Parent()
// 需要重新设置子类的constructor，Child.prototype = new Parent()相当于子类的原型对象完全被覆盖了
Child.prototype.constructor = Child
```

5、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点

```javascript
function Parent() {
  this.name = 'fedaily'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {
  Parent.call(this)
  this.topic = 'fe'
}

// 仔细看这个函数的实现
inherit(Child, Parent)

function inherit(child, parent) {
  var prototype = object(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

// 这个函数的作用可以理解为复制了一份父类的原型对象
// 如果直接将子类的原型对象赋值为父类原型对象
// 那么修改子类原型对象其实就相当于修改了父类的原型对象
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```

6、ES6

ES6提供了class语法糖，同时提供了extends用于实现类的继承。这也是项目开发中推荐使用的方式。

```javascript
class Parent {
  constructor() {
    this.name = 'fedaily'
  }

  getName() {
    return this.name
  }
}

class Child extends Parent {
  constructor() {
    // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明
    super()
    this.topic = 'fe'
  }
}

const child = new Child()
child.getName() // fedaily
```

##### 3、数据类型

基本数据类型：

​	number,string,boolean,symbol,null,undefined

引用数据类型：

​	array,object,function等

##### 4、let,const和var

​	var支持变量提升，而let和const声明的变量存在暂时性死区，需提前声明o才能调用。

​	const和let是块级作用域，而var是函数级作用域，const声明需设置初始值，const声明引用类型常量，可修改常量的属性。var可重复定义同名变量。

​	const和let缩小了变量作用域，避免了变量污染。

##### 5、es6新规范

​	1、let和const

​	2、箭头函数，箭头函数是匿名函数，存在暂时性死区，调用前需提前声明，箭头函数的this指向调用该箭头函数所在的作用域。

​	3、模板字符串，${变量名}

​	4、数组和对象的解构，剩余参数

##### 6、new的过程

​	1、创建一个新的空对象

​	2、将空对象的`_proto_`指向构造函数的原型对象

​	3、将新对象作为构造函数的上下文（改变this指向）

​	4、判断返回值类型，将初始化完毕的新对象地址，保存到等号左边的变量中

##### 7、this指向

​	1、作为函数调用，this指向全局对象（window）。

​	2、作为对象的方法调用，this指向该对象。

​	3、作为构造函数调用，this指向新创建的对象。

​	4、通过call和apply指定this。

##### 8、bind

​	